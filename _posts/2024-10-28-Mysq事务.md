---
layout: post
title: "Mysql事务"
date:   2024-10-28
tags: [八股]
comments: true
author: zy0410
---

## 事务特性

>  ACID：

1. 原子性(Atomicity):一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。
2. 一致性(Consistency):是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
3. 隔离性(Isolation):数据库允许多个==并发事务==同时对其数据进行读写和修改的能力隔离性可以防止多个事务并发执行时由于交又执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。
4. 持久性(Durability):事务处理结束后对数据的修改就是永久的，即便系统故障也不会丢失。

> InnoD8 引擎通过什么技术来保证事务的这四个特性的呢?

1. 持久性是通过 redo log(重做日志)来保证的;
2. 原子性是通过 undo log(回滚日志)来保证的;
3. 隔离性是通过 MVCC(多版本并发控制)或锁机制来保证的;
4. 一致性则是通过持久性+原子性+隔离性来保证;

> 并发事务会引发什么问题

1. 脏读：如果A事务**读到了**另一个**未提交B事务修改过的数据**，"就意味着发生了**脏读**现象。因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作。
2. 不可重复读：在A事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了**不可重复读**现象。此时B事务已提交事务。
3. 幻读：在一个事务内多次查询某个符合查询条件的**记录数量**，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了**幻读**现象。

> 事务隔离级别

1. 读未提交(read uncommitted)，指一个事务还没提交时，它做的变更就能被其他事务看到;==脏读，不可重复读，幻读==
2. 读提交(read committed)，指一个事务提交之后，它做的变更才能被其他事务看到;==不可重复读，幻读==
3. 可重复读(repeatable read)，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB引擎的默认隔离级别，==幻读==
4. 串行化(serializable);会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行;

注意：**MySQL InnoDB 引擎的默认隔离级别虽然是可重复读，但是它很大程度上避免幻读现象(并不是完全解决了)**解决方式有两种：

- 针对==快照读==(普通 select 语句)，是通过MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对==当前读==(select ... for update 等语句)，是通过 next-keylock(记录锁+间隙锁)方式解决了幻读，因为当执行 select..for update 语句的时候，会加上 next-keylock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题

> 隔离级别的实现

- 对于**读未提交**隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了;
- 对于**串行化**隔离级别的事务来说，通过加读写锁的方式来避免并行访问;
- 对于**读提交**和**可重复读**隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**读提交**隔离级别是在**每个语句执行前**都会重新生成一个 Read View,而**可重复读**隔离级别是**启动事务时**然后整个事务期间都生成一个 Read View，在用这个 Read View。

> Read View

1. Read View中的四个字段

   - m_ids :指的是在创建 Read View 时，当前数据库中**活跃事务**的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。
   - min_trx id :指的是在创建 Read View 时当前数据库中**活跃事务**中事务 id 最小的事务，也就是 m_ids 的最小值。
   - max_trx_id :这个并不是 m ids 的最大值而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值+1;
   - creator_trx _id :指的是创建该 Read View的事务的事务 id。

2. 聚簇索引记录中的两个隐藏列

   - trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在trx_id 隐藏列里
   - roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧日版本的记录写入到 undo日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

3. trx_id可划分为三种情况：

   - 如果记录的 trx id 值小于 Read View 中min_trx_id 值，表示这个版本的记录是在创建 Read View ==前==已经提交的事务生成的所以该版本的记录对当前事务==可见==。
   - 如果记录的 trx_id 值大于等于 Read View中的 max_trx_id 值，表示这个版本的记录是在创建 Read View ==后==才启动的事务生成的,所以该版本的记录对当前事务==不可见==。
   - 如果记录的 trx_id 值在 Read View 的max_trx_id 之间，需要min_trx_id 和判断 trx_id 是否在 m ids 列表中：如果记录的 trx _id ==在==m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着(还没提交事务)，所以该版本的记录对当前事务==不可见==。m_ids 列表中如果记录的 trx_id ==不在==表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务==可见==。

   **这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC(多版本并发控制)**

> 可重复读是如何工作的

**可重复读隔离级别是启动事务时生成一个 Read View,然后整个事务期间都在用这个 Read View**

通过执行第一个select时生成的Read View与聚簇索引中的隐藏列“比较”

> 读提交是如何工作的

**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。**



> 当前读–mvcc

简单的select操作(不包括 select ... lock in share mode, select ... for update)

- 在**可重复读**级别下,，mvcc完全解决了重复读，但并不能真正的完全避免幻读，只是在部分场景下利用历史数据规避了幻读。
- 对于快照读，mysql使用mvcc利用历史数据部分避免了幻读(在某些场景看上去规避了幻读)，要完全避免，需要手动加锁将快照读调整为当前读(mysql不会自动加锁)，然后mysql使用next-key完全避免了幻读(对加锁的时机有要求)。

> 当前读

select ... lock in share mode
select ... for update
insert、update、delete

> 注意

- 事务的==快照==时间点是以第一个select来确认的。所以即便事务先开始。但是select在后面的事务的update之类的语句后进行，那么它是可以获取前面的事务的对应的数据。
- mysal中数据的存放会通过版本记录一系列的历史数据，这样，可以根据版本香找数据。

> 幻读在可重复读下未完全解决

1. 对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。
2. 对于当前读，如果事务开启后并没有执行当前读，而是==先快照读==，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。