---
layout: post
title: "分布式锁解决库存超卖"
date:   2024-10-29
tags: [八股]
comments: true
author: zy0410
---

## 分布式锁解决库存超卖

库存超卖问题是有很多种技术解决方案的，比如悲观锁，分布式锁，乐观锁，队列串行化，Redis原子操作等等。

那么分布式锁解决库存超卖？

在高并发场景下如何优化分布式锁的并发性能？

### 库存超卖现象是怎么产生的

不同的用户同时买商品，同时查询剩余库存且库存大于一个用户的购买数量，但是小于所有用户的购买数量。于是库存出现了负数。

### 分布式锁如何解决库存超卖问题

原理：同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。

只有一个订单系统实例可以成功加分布式锁，只有这一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存不足了，库存不足，无法购买，下单失败。不会将库存扣减为负数的。

### 其他方案

悲观锁，分布式锁，乐观锁，队列串行化，异步队列分散，Redis原子操作等等

### 分布式锁的方案在高并发场景下

> 分布式锁的方案在高并发场景下有什么问题

分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。

缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。

### 如何对分布式锁进行高并发优化

核心:分段加锁

- 把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。

- 接着，每秒1000个请求过来了，此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。

- 这样同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -> 判断库存是否充足 -> 扣减库存。

  

但是:

做了分段处理之后，有一个坑：就是如果某个下单请求，加锁了，然后发现这个分段库存里的库存不足了，此时咋办？

这时需要自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现。

### 分布式锁并发优化方案的不足

- 首先，你得对一个数据分段存储，一个库存字段本来好好的，现在要分为20个分段库存字段；
- 其次，你在每次处理库存的时候，还得自己写随机算法，随机挑选一个分段来处理；
- 最后，如果某个分段中的数据不足了，你还得自动切换到下一个分段数据去处理。